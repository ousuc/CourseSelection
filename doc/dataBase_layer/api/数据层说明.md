## 使用数据库类型和版本

为了做到数据持久化
所以使用了postgresql数据库
具体使用版本如下：
postgresql: 18.1-1
postgresql-libs: 18.1-1
libpqxx:7.10.1-1

## 设计方案（具体请看设计文档和api文件夹统计的design文件夹内部）
使用了一种极简的一种broker模式
总共5个类, 就是外部可以直接使用broker和数据库进行交互
是一种类似封装的效果
DataBroker CourseBroker StudentBroker...
然后将这个之间关联的时候使用外部的controller（这个是在应用逻辑层）来使用并且实现  
至于没有设计GradeBroker这个原因是因为这个Grade应该是由老师或者其他来进行经管  
但是我的想法可能并不是最好的，如果需要更改什么请提出一些issue

## 接口文档
### DataBroker  数据库经理人

连接一个数据库，能够管理库。
是对于pqxx的特定封装，是一个utility但是并不是静态的
比如连接和断开数据库的连接，为了各种不同的数据库进行准备
> 不对外公开


---

注意：每一个接下来介绍到的Broker内部都有一个构造函数接收一个DataBroker指针
如果两个Broker创建的时候使用的指针是相同的那么就是证明维护的是同一个数据库

---
## TeacherBroker  教师经理人

维护教师表
提供如下方法：

添加老师->更新
bool saveTeacher(Teacher* t)   
通过id来查询对应老师->查询    
Teacher* findTeacherById(std::string id)  
给老师分配对应的课程->更新    
bool assignToCourse(std::string teacherId, std::string courseId)   
输出学生的成绩（老师负责的）->查询    
inputStudentGrade(std::string teacherId, std::string studentId, float)    

### CourseBroker 课程经理人

维护课程表
提供如下方法：

添加课程->更新         
bool saveCourse(DataBroker* db)           
通过课程id查询课程信息->查询
Course* findCourseById(std:string)           
激活课程->更新      
bool activateCourse(std::string courseId)         
失活课程->更新      
bool deactivateCourse(std::string courseId)      
是否激活课程->查询      
bool isactiveCourse(std::string courseId)      
获取全部课程id->查询        
std::vector\<std::string\> getAllCoursesId()        

### StudentBroker

维护学生表
提供以下信息

添加学生->更新       
bool saveStudent(Student* student)      
查找学生通过ID->查询     
Student* findStudentById(std::string id)      
给学生参加课程->更新      
bool enrollInCourse(std::string studentId, std::string courseId)
计算GPA->查询    
float calculateGPA(std::string studentId)       

### TeachingTaskBroker    

维护教学任务表    
提供以下方法：      

添加任务->更新    
bool saveTask(TeachingTask task)       
查找教学任务通过ID->查询     
TeachingTask* findTaskById(std::string id)     
添加学生到教学任务中->更新     
bool addStudentToTask(std::string taskId, std::string studentId)      
分配老师任务->更新      
bool assignTeacherToTask(std::string taskId, std::string teacherId)      
